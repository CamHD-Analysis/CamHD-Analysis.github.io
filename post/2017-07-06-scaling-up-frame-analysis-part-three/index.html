<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>CamHD Video Analysis  | Scaling out Image Analysis, Part Three: the Redis work queue</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.56.0" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    <link href='https://camhd-analysis.github.io/dist/main.css' rel='stylesheet' type="text/css" />
    
      
    

    

    <meta property="og:title" content="Scaling out Image Analysis, Part Three: the Redis work queue" />
<meta property="og:description" content="My image analysis tools are trivially parallelizable. That is, I have a worker which requires a reasonable block of time (an hour or two) to process one video. I can process many videos by running this worker on a bunch of computers, and have them slowly chug through all of the videos on the CI, one at a time.
To control this mayhem, I&rsquo;m using a work queue system built around the RQ library for Python." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://camhd-analysis.github.io/post/2017-07-06-scaling-up-frame-analysis-part-three/" />
<meta property="article:published_time" content="2017-07-06T00:00:00+00:00" />
<meta property="article:modified_time" content="2017-07-06T00:00:00+00:00" />
<meta itemprop="name" content="Scaling out Image Analysis, Part Three: the Redis work queue">
<meta itemprop="description" content="My image analysis tools are trivially parallelizable. That is, I have a worker which requires a reasonable block of time (an hour or two) to process one video. I can process many videos by running this worker on a bunch of computers, and have them slowly chug through all of the videos on the CI, one at a time.
To control this mayhem, I&rsquo;m using a work queue system built around the RQ library for Python.">


<meta itemprop="datePublished" content="2017-07-06T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2017-07-06T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="681">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Scaling out Image Analysis, Part Three: the Redis work queue"/>
<meta name="twitter:description" content="My image analysis tools are trivially parallelizable. That is, I have a worker which requires a reasonable block of time (an hour or two) to process one video. I can process many videos by running this worker on a bunch of computers, and have them slowly chug through all of the videos on the CI, one at a time.
To control this mayhem, I&rsquo;m using a work queue system built around the RQ library for Python."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://camhd-analysis.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      CamHD Video Analysis
    </a>
    <div class="flex-l items-center">
      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/post/" title="Posts page">
              Posts
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/page/" title="Pages page">
              Pages
            </a>
          </li>
          
        </ul>
      
      







  <a href="https://github.com/CamHD-Analysis" class="link-transition github link dib z-999 pt3 pt0-l mr2" title="Github link">
    <svg  height="32px"  style="enable-background:new 0 0 512 512;" version="1.1" viewBox="0 0 512 512" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
  <path d="M256,32C132.3,32,32,134.8,32,261.7c0,101.5,64.2,187.5,153.2,217.9c11.2,2.1,15.3-5,15.3-11.1   c0-5.5-0.2-19.9-0.3-39.1c-62.3,13.9-75.5-30.8-75.5-30.8c-10.2-26.5-24.9-33.6-24.9-33.6c-20.3-14.3,1.5-14,1.5-14   c22.5,1.6,34.3,23.7,34.3,23.7c20,35.1,52.4,25,65.2,19.1c2-14.8,7.8-25,14.2-30.7c-49.7-5.8-102-25.5-102-113.5   c0-25.1,8.7-45.6,23-61.6c-2.3-5.8-10-29.2,2.2-60.8c0,0,18.8-6.2,61.6,23.5c17.9-5.1,37-7.6,56.1-7.7c19,0.1,38.2,2.6,56.1,7.7   c42.8-29.7,61.5-23.5,61.5-23.5c12.2,31.6,4.5,55,2.2,60.8c14.3,16.1,23,36.6,23,61.6c0,88.2-52.4,107.6-102.3,113.3   c8,7.1,15.2,21.1,15.2,42.5c0,30.7-0.3,55.5-0.3,63c0,6.1,4,13.3,15.4,11C415.9,449.1,480,363.1,480,261.7   C480,134.8,379.7,32,256,32z"/>
</svg>

  </a>


    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  <div class="flex-l mt2 mw8 center">
    <article class="center cf pv5 ph3 ph4-ns mw7">
      <p class="f6 b helvetica tracked">
        
        POST
      </p>
      <h1 class="f1 athelas">
        Scaling out Image Analysis, Part Three: the Redis work queue
      </h1>
        
        
      <time class="f6 mv4 dib tracked" datetime="2017-07-06T00:00:00Z">
        July 6, 2017
      </time>
      <section class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray">
        

<p>My image analysis tools are trivially parallelizable.  That is, I have a worker
which requires a reasonable block of time (an hour or two) to process one video.
I can process many videos by running this worker on a bunch of computers, and
have them slowly chug through all of the videos on the CI, one at a time.</p>

<p>To control this mayhem, I&rsquo;m using a work queue system built around the <a href="http://python-rq.org">RQ</a>
library for Python.   I&rsquo;ve created similar systems in the past with <a href="http://resque.github.io">Resque</a> for Ruby,
so the concept is pretty familiar to me.   The work queue model provides
just enough robustness, particularly combined with tools that can be selective about
what jobs go into the queue, and which jobs are actually run when pulled from the queue.</p>

<p>In this case, the input for a worker is an URL to a ProRes file at the <a href="https://rawdata.oceanobservatories.org/files/RS03ASHS/PN03B/06-CAMHDA301/2017/06/14/">raw data
repository</a>,
and the output is a corresponding
<a href="https://github.com/CamHD-Analysis/CamHD_motion_metadata/blob/master/docs/OpticalFlow.md"><code>optical_flow.json</code></a>
file.   I can test for completeness by checking if a <code>.json</code> file exists for
each file on the raw data archive.  Outside of extraordinary circumstances, this
lets me write a simple &ldquo;make sure all of the JSON files exist&rdquo; script which
injects new jobs into the work queue for any video that doesn&rsquo;t have a
corresponding JSON.   If I want to invalidate an optical flow file, I can simply
delete it and re-run the script.</p>

<p>On the other end, the worker won&rsquo;t overwrite an existing JSON file unless explicitly ordered to do so.
Again, this means I can (accidentally) over-stock the work queue with redundant
jobs requests and not burn a lot of cycles making the same file over and over again.</p>

<p>RQ itself is built on top of <a href="https://redis.io">Redis</a> datastore.  I&rsquo;m not really
plumbing the depths of either RQ or Redis, as the default settings work fine.  In this case,
I&rsquo;m running Redis on a Google Cloud Platform instance** to make it accessible to a cluster running on
a pile of desktops in my office and to a second cluster running in the Google cloud.  In practice, you could run Redis on
a local machine for greater security.</p>

<p>** I&rsquo;m running the <a href="https://github.com/bitnami/bitnami-docker-redis">Bitnami Redis container</a> on a GCP instance.  It&rsquo;s totally stock other than <a href="https://docs.bitnami.com/virtual-machine/components/redis/#how-to-change-the-redis-password">setting the password</a>.</p>

<h1 id="worker">Worker</h1>

<p>With RQ, the worker side is trivial.   It doesn&rsquo;t need to be customized
to the application at all, as long as the relevant Python modules can be
found in the Python path.   The full worker source code is <a href="https://github.com/CamHD-Analysis/camhd_motion_analysis/blob/master/python/rq_worker.py">here</a>,
but the majority is taken up with command line argument parsing.  Here&rsquo;s the business end:</p>

<pre><code>conn = Redis.from_url(redis_host)
with Connection(conn):
    w = Worker( args.queues )
    w.work()
</code></pre>

<p>That&rsquo;s it: connect to Redis, get work, do the work.  Of course, to do the work,
Python needs to be able to find all sorts of Python and system dependencies, hence the use of <a href="{{ site.baseurl }}{% post_url 2017-07-05-scaling-up-frame-analysis-part-two %}">Docker images</a></p>

<h1 id="job-injection">Job Injection</h1>

<p>The job injector isn&rsquo;t actually much more complicated (<a href="https://github.com/CamHD-Analysis/camhd_motion_analysis/blob/master/python/rq_client.py">full source here</a>).  As with the worker, it needs to be able to connect to the Redis host.  Otherwise, jobs are queued as:</p>

<pre><code>q = Queue( connection=Redis.from_url(args.redis) )
  for infile in infiles:
      job = q.enqueue( ma.process_file,
                      infile,
                      outfile,
                      lazycache_url = args.lazycache,
                      num_threads=args.threads,
                      stride=args.stride,
                      start=args.start,
                      stop=args.stop,
                      timeout='1024h',
                      result_ttl = 3600*168,
                      ttl=3600*168 )
</code></pre>

<p>Just a simple function call with arguments.   One interesting feature is that
the function args and args to RQ are mixed.  In this case, <code>timeout</code>, <code>result_ttl</code>
and <code>ttl</code> are RQ args, and the rest are for my function <code>process_file</code>.   <code>result_ttl</code> and <code>ttl</code> control the lifespan of pending jobs and jobs results in the Redis datastore.   <code>timeout</code> sets the maximum time workers are allowed to run.</p>

<p>The rest of the script is concerned with connecting to the CI, iterating through
the available movies and seeing which have matching JSON files in the local
repo.</p>

<p>For total parity, I prefer to run the injection script inside a worker Docker image (see the <code>inject</code> task <a href="https://github.com/CamHD-Analysis/camhd-motion-analysis-deploy/blob/master/deploy/Rakefile">here</a>).   This lets me use <code>.env</code> files for configuration, just as I&rsquo;m doing with the workers.</p>

<p><strong>See also <a href="{{ site.baseurl }}{% post_url 2017-06-16-scaling-up-frame-analysis-part-one %}">the introductory post</a> in this series and <a href="{{ site.baseurl }}{% post_url 2017-07-05-scaling-up-frame-analysis-part-two %}">the second post</a> on making Docker images.</strong></p>

      </section>
      


    </article>
    <div class="ph3 mt2 mt6-ns">
      

    </div>
  </div>

    </main>
    <footer class="bg-near-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://camhd-analysis.github.io/" >
    &copy; 2019 CamHD Video Analysis
  </a>
  







  <a href="https://github.com/CamHD-Analysis" class="link-transition github link dib z-999 pt3 pt0-l mr2" title="Github link">
    <svg  height="32px"  style="enable-background:new 0 0 512 512;" version="1.1" viewBox="0 0 512 512" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
  <path d="M256,32C132.3,32,32,134.8,32,261.7c0,101.5,64.2,187.5,153.2,217.9c11.2,2.1,15.3-5,15.3-11.1   c0-5.5-0.2-19.9-0.3-39.1c-62.3,13.9-75.5-30.8-75.5-30.8c-10.2-26.5-24.9-33.6-24.9-33.6c-20.3-14.3,1.5-14,1.5-14   c22.5,1.6,34.3,23.7,34.3,23.7c20,35.1,52.4,25,65.2,19.1c2-14.8,7.8-25,14.2-30.7c-49.7-5.8-102-25.5-102-113.5   c0-25.1,8.7-45.6,23-61.6c-2.3-5.8-10-29.2,2.2-60.8c0,0,18.8-6.2,61.6,23.5c17.9-5.1,37-7.6,56.1-7.7c19,0.1,38.2,2.6,56.1,7.7   c42.8-29.7,61.5-23.5,61.5-23.5c12.2,31.6,4.5,55,2.2,60.8c14.3,16.1,23,36.6,23,61.6c0,88.2-52.4,107.6-102.3,113.3   c8,7.1,15.2,21.1,15.2,42.5c0,30.7-0.3,55.5-0.3,63c0,6.1,4,13.3,15.4,11C415.9,449.1,480,363.1,480,261.7   C480,134.8,379.7,32,256,32z"/>
</svg>

  </a>


  </div>
</footer>

    <script src="https://camhd-analysis.github.io/dist/app.bundle.js" async></script>

  </body>
</html>
