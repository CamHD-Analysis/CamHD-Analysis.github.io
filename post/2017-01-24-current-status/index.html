<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>CamHD Video Analysis  | A Brief Tour of LazyCache Part I, the Software</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.31.1" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    <link href='https://camhd-analysis.github.io/dist/main.css' rel='stylesheet' type="text/css" />
    
      
    

    

    <meta property="og:title" content="A Brief Tour of LazyCache Part I, the Software" />
<meta property="og:description" content="With the time set aside for the eScience Incubator, I&rsquo;ve reached a (very) minimal working example of the CamHD caching/server software which is fully deployable to a Google Compute Engine instance. It isn&rsquo;t terribly stable or configurable, but I can make improve those slowly.
It seems like a good time to step back, take stock and document. At this point I&rsquo;m going to worry about how I&rsquo;m doing it. What and why I&rsquo;m doing it is a whole &lsquo;nother story." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://camhd-analysis.github.io/post/2017-01-24-current-status/" />



<meta property="article:published_time" content="2017-01-24T00:00:00&#43;00:00"/>

<meta property="article:modified_time" content="2017-01-24T00:00:00&#43;00:00"/>











<meta itemprop="name" content="A Brief Tour of LazyCache Part I, the Software">
<meta itemprop="description" content="With the time set aside for the eScience Incubator, I&rsquo;ve reached a (very) minimal working example of the CamHD caching/server software which is fully deployable to a Google Compute Engine instance. It isn&rsquo;t terribly stable or configurable, but I can make improve those slowly.
It seems like a good time to step back, take stock and document. At this point I&rsquo;m going to worry about how I&rsquo;m doing it. What and why I&rsquo;m doing it is a whole &lsquo;nother story.">


<meta itemprop="datePublished" content="2017-01-24T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2017-01-24T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="1132">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="A Brief Tour of LazyCache Part I, the Software"/>
<meta name="twitter:description" content="With the time set aside for the eScience Incubator, I&rsquo;ve reached a (very) minimal working example of the CamHD caching/server software which is fully deployable to a Google Compute Engine instance. It isn&rsquo;t terribly stable or configurable, but I can make improve those slowly.
It seems like a good time to step back, take stock and document. At this point I&rsquo;m going to worry about how I&rsquo;m doing it. What and why I&rsquo;m doing it is a whole &lsquo;nother story."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://camhd-analysis.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      CamHD Video Analysis
    </a>
    <div class="flex-l items-center">
      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/post/" title="Posts page">
              Posts
            </a>
          </li>
          
        </ul>
      
      








    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  <div class="flex-l mt2 mw8 center">
    <article class="center cf pv5 ph3 ph4-ns mw7">
      <p class="f6 b helvetica tracked">
        
        POST
      </p>
      <h1 class="f1 athelas">
        A Brief Tour of LazyCache Part I, the Software
      </h1>
        
        
      <time class="f6 mv4 dib tracked" datetime="2017-01-24T00:00:00Z">
        January 24, 2017
      </time>
      <section class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray">
        

<p>With the time set aside for the <a href="https://github.com/uwescience/incubator2017">eScience Incubator</a>, I&rsquo;ve reached a (very) minimal working example of the CamHD caching/server software which is fully deployable to a <a href="http://cloud.google.com/">Google Compute Engine</a> instance.   It isn&rsquo;t terribly stable or configurable, but I can make improve those slowly.</p>

<p>It seems like a good time to step back, take stock and document.     At this point I&rsquo;m going to worry about <em>how</em> I&rsquo;m doing it.  <em>What</em> and <em>why</em> I&rsquo;m doing it is a whole &lsquo;nother story.</p>

<p>Let&rsquo;s start at the top.  The caching software is written in Go.   Following the Go idiom, the software is written as a set of modular libraries:</p>

<ul>
<li><p><a href="https://github.com/amarburg/go-lazyfs">go-lazyfs</a> defines an interface for performing &mdash; and optionally caching &mdash; random access from files over HTTP.</p></li>

<li><p><a href="https://github.com/amarburg/go-quicktime">go-quicktime</a> parses the tree of Atoms in a <a href="https://developer.apple.com/library/content/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1">Quicktime</a> file.</p></li>

<li><p><a href="https://github.com/amarburg/goav">goav</a> uses <a href="https://golang.org/cmd/cgo/"><code>cgo</code></a> to import the <a href="https://www.ffmpeg.org/">FFMpeg API</a> into Go.   Forked from <a href="https://github.com/giorgisio/goav">here</a>.</p></li>

<li><p><a href="https://github.com/amarburg/go-prores-ffmpeg">go-prores-ffmpeg</a> uses <code>go-quicktime</code> to find and retrieve individual frames within a movie, then uses <code>goav</code> to convert the enclosed data (in ProRes format) into the Go <a href="https://golang.org/pkg/image/"><code>Image</code></a> format.</p></li>
</ul>

<p>These packages are all used to build <a href="https://github.com/amarburg/go-lazycache">go-lazycache</a>, our &ldquo;app.&rdquo; At heart it&rsquo;s just a web server built using the Go <a href="https://golang.org/pkg/net/http/"><code>net/http</code></a>, but it performs different behaviors depending on the path passed to it.</p>

<h2 id="testing-the-code">Testing the code</h2>

<p>Thanks to the flexible Go packaging system, it&rsquo;s pretty straightforward to build a go application.</p>

<p>To run lazycache, need to have <code>go</code> <strong>and</strong> the <a href="https://www.ffmpeg.org/">FFMpeg</a> libraries (libavcodec, etc.) installed.  Note that there was a period when both Debian and Ubuntu used the alternative <a href="https://libav.org/">libav</a> libraries which have the same names, but which aren&rsquo;t compatible.   Ubuntu distributions from 2016 on (Xenial, etc.) have returned to using &ldquo;real&rdquo; ffmpeg.   In an Ubuntu operating system, I believe:</p>

<pre><code>sudo apt-get install libavcodec-dev libavdevice-dev libavutil-dev libswresample-dev libavfilter-dev libswscale-dev
</code></pre>

<p>will get all of the relevant packages, though I haven&rsquo;t tested it&hellip;</p>

<p>Alternatively, I built a <a href="https://hub.docker.com/r/amarburg/golang-ffmpeg/">Docker image</a> based on the Debian-based-version of the <a href="https://hub.docker.com/_/golang/">official Go language docker image</a>.   Everything described here can be done in an instance of that image (assuming you have <a href="https://www.docker.com/">Docker</a> installed):</p>

<pre><code>docker run --tty -i --rm --publish 5000:5000 amarburg/golang-ffmpeg:wheezy-1.8
</code></pre>

<p>(the <code>--publish</code> is required to expose the webserver, as shown below)</p>

<p>Assuming <a href="https://golang.org/doc/code.html">GOPATH has been set</a>, download and build <code>go-lazycache</code> and all of its Go dependencies &mdash; both those that I&rsquo;ve written like <code>go-lazyfs</code> and deps from further upstream:</p>

<pre><code>% cd $GOPATH
% go get github.com/amarburg/go-lazycache
</code></pre>

<p><em>(right now, this will spit out a bunch of deprecated function warnings from ffmpeg.   Sorry!)</em></p>

<p>And builds the binary <code>lazycache-server</code> and installs it in <code>$GOPATH/bin/</code></p>

<pre><code>% go install github.com/amarburg/go-lazycache/cmd/lazycache-server
</code></pre>

<p>(it is apparently idiomatic way to put binaries for a Go package in their own <code>cmd/</code> subdirectory )</p>

<p>The application can then be run:</p>

<pre><code>% bin/lazycache-server
[rawdata oceanobservatories org]
Querying directory: https://rawdata.oceanobservatories.org//
Could not detect type for /
registering root node at  /org/oceanobservatories/rawdata/
Starting http handler at http://0.0.0.0:5000/
Fs at http://0.0.0.0:5000/org/oceanobservatories/rawdata/
....
</code></pre>

<p>This will start the application, which will listen on the local port 5000.   Opening a web browser to <code>http://localhost:5000/org/oceanobservatories/rawdata/files/</code> should produce JSON describing the contents of the directory <a href="https://rawdata.oceanobservatories.org/files/"><code>https://rawdata.oceanobservatories.org/files/</code></a> on the OOI Raw data portal.</p>

<p>{:center}
<img src="{{site.baseurl}}/images/lazycache_sample_page.jpg" alt="Sample image of Lazycache" /></p>

<p><em>Technically speaking <code>http://localhost:5000/org/oceanobservatories/rawdata/</code> would work, but the top level at the rawdata archive, <code>http://rawdata.oceanobservatories.org/</code> isn&rsquo;t indexable&hellip;.</em></p>

<h2 id="docker">Docker</h2>

<p>Docker forms the next layer of pyramid of tools.   Lazycache can certainly be run as a standalone program, but is intended for deployment as a Docker container.  This brings all of the deployment and versioning benefits of Docker, and also lets us control dependencies (like the somewhat tricky FFMpeg versioning).</p>

<p>Files related to deploying lazycache are stored in a separate repository, <a href="https://github.com/amarburg/go-lazycache-app">lazycache-deploy</a>.   Within that repo, the Dockerfile
essentially replicates the steps detailed above:</p>

<pre><code>FROM amarburg/golang-ffmpeg:wheezy-1.8

RUN go get github.com/amarburg/go-lazycache
RUN go install github.com/amarburg/go-lazycache/cmd/lazycache-server/

COPY service_account.json /go/
ENV GOOGLE_APPLICATION_CREDENTIALS=/go/service_account.json

ENTRYPOINT /go/bin/lazycache-server

# Document that the service listens on port 5000
EXPOSE 5000
</code></pre>

<p>This builds on the <a href="https://github.com/amarburg/docker-golang-ffmpeg">docker-golang-ffmpeg</a> image mentioned earlier.   The two lines in the middle re <code>service_account.json</code> install a JSON authentication key to access a Google Storage bucket.  Ignore for now.</p>

<h1 id="wercker">Wercker</h1>

<p>I&rsquo;ve started using <a href="http://www.wercker.com/">wercker</a> for continuous integration.   CI services allow us to trigger automated processing every time a Github repository is updated.   For individual Go repos, I run built-in test routines.    For Docker images (both <code>golang-ffmpeg</code> and <code>lazycache-deploy</code>), I can actually build a docker image and automatically push it to a Docker repository (I could do this manually on my laptop, too, of course&hellip;.)</p>

<p>One minor twist is that Wercker is itself Docker based.   To enroll a repository in Wercker, a <code>wercker.yml</code> file must be created in the repository.   This specifies the steps required to build and test the repo.   For <code>go-lazyfs</code> this is looks like:</p>

<pre><code>box: golang

build:
  steps:
    # Sets the go workspace and places you package
    # at the right place in the workspace tree
    - setup-go-workspace

    - script:
        name: go get
        code: |
          go get -t

    # Build the project
    - script:
        name: go build
        code: |
          go build ./...

    # Test the project
    - script:
        name: go test
        code: |
          go test ./...
</code></pre>

<p>Which is pretty straightforward.   It specifies that the tests should run in the Docker image <a href="https://hub.docker.com/_/golang/"><code>golang</code></a> (I can use the official Go Docker image because <code>go-lazyfs</code> doesn&rsquo;t require FFMpeg).   It specifies a single &ldquo;pipeline&rdquo; called &ldquo;build&rdquo; which contains four steps, first a canned Go setup routine (provided by wercker), then the standard go sequence of get-build-test.</p>

<p>wercker automatically checks out and works in a copy of the current repository (the one begin tested), so the <code>go</code> commands don&rsquo;t need to specify which project to get-build-test, it assumes the current one (<code>go-lazyfs</code> in this case).</p>

<h2 id="building-docker-images-in-wercker">Building Docker images in Wercker</h2>

<p>This leads to an interesting inside-out arrangement.   Wercker works inside a Docker image.   It would be most efficient to just use Wercker to set up the image as desired, then &ldquo;can it&rdquo; and publish it &hellip; but since the testing is actually occuring <em>within</em> a Docker image, you can&rsquo;t reach &ldquo;outside&rdquo; of the Docker image (this would seriouly break the Docker security model).</p>

<p>To get around this, wercker provides a number of custom &ldquo;steps&rdquo; for pushing the current image to Docker Hub, Google, etc.   It&rsquo;s a bit hackish, but works.   The one strangeness is that the construction of Docker images is now defined by the <code>wercker.yml,</code> <em>not</em> in a Dockerfile.</p>

<p>For example, this is the wercker.yml for [docker-golang-ffmpeg]()</p>

<pre><code>box: golang:1.8-wheezy

build:
  steps:
    - install-packages:
         packages: autoconf bzip2 cmake libtool libssl-dev

    - script:
        name: Configure environment
        code: |
          sh ./environment.sh

    - script:
        name: Build FFMPEG
        code: |
          ./build_ffmpeg.sh

    # Push completed builds to Docker hub
    - internal/docker-push:
        username: $USERNAME
        password: $PASSWORD
        tag: wheezy-1.8
        repository: amarburg/golang-ffmpeg
        registry: https://registry.hub.docker.com
</code></pre>

<p>The dirty work is done by the <code>build_ffmpeg.sh</code> script.   <code>internal/docker-push</code> is the magic step provided by wercker which pushes the final image to Docker hub (in this case).</p>

<h1 id="whew">Whew</h1>

<p>More about working with Google Cloud Platform in <a href="{{site.baseurl}}{% post_url 2017-01-25-deploying-to-google-cloud %}">part 2</a>.</p>

      </section>
      


    </article>
    <div class="ph3 mt2 mt6-ns">
      







  <div class="bg-light-gray pa3">
    <ul>
      <li class="list b mb3">
        21 More Posts
      </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/post/2017-11-17-new-documentation/" class="link ph2 pv2 db black">
            Improvements to CamHD_Motion_Metadata documentation
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/post/2017-10-05-new-faster-lazycache/" class="link ph2 pv2 db black">
            Performance improvements to Lazycache
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/post/2017-09-11-publications-page/" class="link ph2 pv2 db black">
            Publications....
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/post/2017-07-27-using-the-regions-data/" class="link ph2 pv2 db black">
            How to use the regions metadata
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/post/2017-07-13-ci-stats/" class="link ph2 pv2 db black">
            Some CI statistics
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/post/2017-07-07-initial-performance-data/" class="link ph2 pv2 db black">
            First performance benchmarks from scaled-out processing
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/post/2017-07-06-scaling-up-frame-analysis-part-three/" class="link ph2 pv2 db black">
            Scaling out Image Analysis, Part Three: the Redis work queue
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/post/2017-07-05-scaling-up-frame-analysis-part-two/" class="link ph2 pv2 db black">
            Scaling out Image Analysis, Part Two:   Making the Docker Image
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/post/2017-06-16-scaling-up-frame-analysis-part-one/" class="link ph2 pv2 db black">
            Scaling out Image Analysis, Part One
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/post/2017-05-15-benchmarking-pycamhd-part-two/" class="link ph2 pv2 db black">
            Benchmarking Frame Access Methods (again)
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/post/2017-05-02-benchmarking-on-google-compute-engine/" class="link ph2 pv2 db black">
            Benchmarking Frame Access Methods II, Google Compute Engine
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/post/2017-05-01-benchmarking-pycamhd/" class="link ph2 pv2 db black">
            Benchmarking Frame Access Methods
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/post/2017-05-01-camhdhub-is-live/" class="link ph2 pv2 db black">
            CamHD Compute Hub is Live!
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/post/2017-02-14-escience-midterm/" class="link ph2 pv2 db black">
            eScience Winter Incubator Mid-term Checkin
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/post/2017-02-13-trying-out-deis-workflow/" class="link ph2 pv2 db black">
            My Notes on Trying out Deis Workflow on Google Container Engine
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/post/2017-01-25-deploying-to-google-cloud/" class="link ph2 pv2 db black">
            A Brief Tour of LazyCache Part II, Deploying to Google Cloud Platform
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/post/2017-01-24-current-status/" class="link ph2 pv2 db black o-50">
            A Brief Tour of LazyCache Part I, the Software
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/post/2017-01-05-escience-incubator/" class="link ph2 pv2 db black">
            Winter 2017 eScience Incubator
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/post/2016-12-26-lazyfs-and-friends/" class="link ph2 pv2 db black">
            LazyFS Rev 1
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/post/2016-12-02-time-lapse/" class="link ph2 pv2 db black">
            Sample Time Lapse Movies
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/post/2016-11-30-thinking-aloud-about-specs/" class="link ph2 pv2 db black">
            Thinking out loud about accessing CamHD data
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/post/2016-11-01-first-post/" class="link ph2 pv2 db black">
            Project kickoff!
          </a>
        </li>
      
    </ul>
  </div>


    </div>
  </div>

    </main>
    <footer class="bg-near-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://camhd-analysis.github.io/" >
    &copy; 2017 CamHD Video Analysis
  </a>
  








  </div>
</footer>

    <script src="https://camhd-analysis.github.io/dist/app.bundle.js" async></script>

  </body>
</html>
