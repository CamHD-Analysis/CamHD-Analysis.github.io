<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>CamHD Video Analysis  | A Brief Tour of LazyCache Part II, Deploying to Google Cloud Platform</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.56.0" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    <link href='https://camhd-analysis.github.io/dist/main.css' rel='stylesheet' type="text/css" />
    
      
    

    

    <meta property="og:title" content="A Brief Tour of LazyCache Part II, Deploying to Google Cloud Platform" />
<meta property="og:description" content="UPDATE Feb 14 2017: For a bunch of reasons (mostly having to do with triggering CI builds), I decided lazycache-deploy didn&rsquo;t need to be its own repo. It&rsquo;s now a sub-directory of https://github.com/amarburg/go-lazycache-app. I&rsquo;ve done an imperfect modification of the text below&hellip;
For totally arbitrary, er, I mean perfectly reasonable reasons, I&rsquo;ve decided to target Google Cloud Platform as my strawman &ldquo;commercial cloud&rdquo; provider. I still believe there&rsquo;s a use case for deploying the software &mdash; or some subset of it &mdash; on a local or lab machine, but it certainly makes a lot of sense to have the server capable of running in the cloud, whether it&rsquo;s public or strictly private to service a set of local compute instances, so this seemed like a good place to start." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://camhd-analysis.github.io/post/2017-01-25-deploying-to-google-cloud/" />
<meta property="article:published_time" content="2017-01-25T00:00:00+00:00" />
<meta property="article:modified_time" content="2017-01-25T00:00:00+00:00" />
<meta itemprop="name" content="A Brief Tour of LazyCache Part II, Deploying to Google Cloud Platform">
<meta itemprop="description" content="UPDATE Feb 14 2017: For a bunch of reasons (mostly having to do with triggering CI builds), I decided lazycache-deploy didn&rsquo;t need to be its own repo. It&rsquo;s now a sub-directory of https://github.com/amarburg/go-lazycache-app. I&rsquo;ve done an imperfect modification of the text below&hellip;
For totally arbitrary, er, I mean perfectly reasonable reasons, I&rsquo;ve decided to target Google Cloud Platform as my strawman &ldquo;commercial cloud&rdquo; provider. I still believe there&rsquo;s a use case for deploying the software &mdash; or some subset of it &mdash; on a local or lab machine, but it certainly makes a lot of sense to have the server capable of running in the cloud, whether it&rsquo;s public or strictly private to service a set of local compute instances, so this seemed like a good place to start.">


<meta itemprop="datePublished" content="2017-01-25T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2017-01-25T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="1865">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="A Brief Tour of LazyCache Part II, Deploying to Google Cloud Platform"/>
<meta name="twitter:description" content="UPDATE Feb 14 2017: For a bunch of reasons (mostly having to do with triggering CI builds), I decided lazycache-deploy didn&rsquo;t need to be its own repo. It&rsquo;s now a sub-directory of https://github.com/amarburg/go-lazycache-app. I&rsquo;ve done an imperfect modification of the text below&hellip;
For totally arbitrary, er, I mean perfectly reasonable reasons, I&rsquo;ve decided to target Google Cloud Platform as my strawman &ldquo;commercial cloud&rdquo; provider. I still believe there&rsquo;s a use case for deploying the software &mdash; or some subset of it &mdash; on a local or lab machine, but it certainly makes a lot of sense to have the server capable of running in the cloud, whether it&rsquo;s public or strictly private to service a set of local compute instances, so this seemed like a good place to start."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://camhd-analysis.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      CamHD Video Analysis
    </a>
    <div class="flex-l items-center">
      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/post/" title="Posts page">
              Posts
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/page/" title="Pages page">
              Pages
            </a>
          </li>
          
        </ul>
      
      








    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  <div class="flex-l mt2 mw8 center">
    <article class="center cf pv5 ph3 ph4-ns mw7">
      <p class="f6 b helvetica tracked">
        
        POST
      </p>
      <h1 class="f1 athelas">
        A Brief Tour of LazyCache Part II, Deploying to Google Cloud Platform
      </h1>
        
        
      <time class="f6 mv4 dib tracked" datetime="2017-01-25T00:00:00Z">
        January 25, 2017
      </time>
      <section class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray">
        

<p><strong>UPDATE Feb 14 2017</strong>:   For a bunch of reasons (mostly having to do with triggering CI builds), I decided <code>lazycache-deploy</code> didn&rsquo;t need to be its own repo.  It&rsquo;s now a sub-directory of <a href="https://github.com/amarburg/go-lazycache-app">https://github.com/amarburg/go-lazycache-app</a>.  I&rsquo;ve done an imperfect modification of the text below&hellip;</p>

<p>For totally arbitrary, er, I mean perfectly reasonable reasons, I&rsquo;ve decided to target <a href="https://cloud.google.com/">Google Cloud Platform</a> as my strawman &ldquo;commercial cloud&rdquo; provider.   I still believe there&rsquo;s a use case for deploying the software &mdash; or some subset of it &mdash; on a local or lab machine, but it certainly makes a lot of sense to have the server <em>capable</em> of running in the cloud, whether it&rsquo;s public or strictly private to service a set of local compute instances, so this seemed like a good place to start.</p>

<p>As much as I&rsquo;m learning Go on the go (heh), I&rsquo;m learning GCP even more on the, uh, go.   Everything I describe here was figured out on the fly using the $<sup>300</sup>&frasl;<sub>60</sub> day trial period for GCP, and I totally respect that I could be doing it completely wrong.    In keeping with my general philosophy, I&rsquo;m trying to understand the whole process from the bottom up &hellip;. with an eye of eventually moving to automation that gives me as much functionality &ldquo;for free&rdquo; as possible.</p>

<p>At this point, please don&rsquo;t consider this a HOW-TO, because I&rsquo;m sure there I&rsquo;ve missed steps along the way for setting up a new Google Account, project, enabling APIs, that sort of thing.  This is more of a &ldquo;I think this is what I&rsquo;m doing&rdquo;, and with luck this will eventually evolve into a HOWTO/Best Practices documentation.</p>

<p>At a super-high-level, my immediate goals are to:</p>

<ul>
<li>Get <a href="https://github.com/amarburg/go-lazycache"><code>go-lazycache</code></a> running in the cloud.</li>
<li>Do so in a repeatable / documentable manner</li>
</ul>

<p>This drives a couple of engineering decisions:</p>

<ul>
<li>Package <a href="https://github.com/amarburg/go-lazycache"><code>go-laycache</code></a> into a <a href="https://github.com/amarburg/go-lazycache-app">Docker image</a></li>
<li>Run that Docker image in the cloud, in part so I can think long-term about a cluster of Docker images running on a cluster of instances ala <a href="https://kubernetes.io/">Kubernetes</a>/<a href="https://www.docker.com/products/docker-swarm">Docker Swarm</a>, rather than thinking about specific instances with specific jobs.</li>
<li>Store some of the cached file results in online bucket storage.</li>
</ul>

<p>One thing that&rsquo;s missing right now is connection to a database-like store (whether it&rsquo;s <a href="https://cloud.google.com/datastore/">Google Cloud Datastore</a> or a NoSQL running in another container).   In the code, there are points where caching to disk is appropriate, and points where caching to a db is more appropriate.  At present I&rsquo;m only handling the former.</p>

<p>Another big caveat is that <code>go-lazycache</code> isn&rsquo;t configurable right now, so it contains some hard-coded paths into Google Cloud Storage, for example.   I obviously need to fix that.</p>

<h1 id="basic-setup">Basic setup</h1>

<p>Right now I&rsquo;m on the free / trial tier of Google Cloud, and everything is sitting in a single project.   For simplicity, I&rsquo;ll give it the ID <em>cloud-project-1234</em> (if following along, your project will have a different ID, obviously).   Within that project I&rsquo;m using the <a href="https://cloud.google.com/compute/">Compute Engine</a>:</p>

<p>{:center}
<img src="{{site.baseurl}}/images/compute_engine_dashboard.jpg" alt="" /></p>

<p><a href="https://cloud.google.com/storage/">Cloud Storage</a>:</p>

<p>{:center}
<img src="{{site.baseurl}}/images/cloud_storage_dashboard.jpg" alt="" /></p>

<p>and <a href="https://cloud.google.com/container-engine/">Container Engine</a>:</p>

<p>{:center}
<img src="{{site.baseurl}}/images/container_engine_dashboard.jpg" alt="" /></p>

<p>For repeatability, I&rsquo;ve tried to use the <a href="https://cloud.google.com/sdk/gcloud/"><code>gcloud</code></a> command line as much as possible, but I haven&rsquo;t spent a lot of time on true automation (like querying status, then run particular commands based on the response).   I think 99% (if not 100%) of what I&rsquo;m doing can be done exclusively through the website console.</p>

<h1 id="building-the-image">Building the image</h1>

<p>As a touched on in <a href="{{site.baseurl}}{% post_url 2017-01-24-current-status %}">Part 1</a>, I&rsquo;m using <a href="http://www.wercker.com/">Wercker</a> for CI and also for building Docker images.   In that post, I described building the <a href="https://www.github.com/amarburg/docker-golang-ffmpeg">docker-golang-ffmpeg</a> image, my base image which consists of Go and a bunch of FFMpeg libraries.   That project has Wercker automatically push the resulting image to the public <a href="https://hub.docker.com/r/amarburg/golang-ffmpeg/">Docker Hub</a>.</p>

<p>Lazycache is deployed similarly, but the image is stored in the Google Container Registry for the project.  This stores the Docker image in Google Cloud Storage (so you pay for it), but it&rsquo;s private and local to the project.</p>

<p>As previously noted, any manipulation of the Docker image itself by Wercker requires a magic step which can escape from the Docker jail.   This is the <code>wercker.yml</code> from <a href="https://github.com/amarburg/go-lazycache-app/"><code>go-lazycache-app</code></a>:</p>

<pre><code>  # wercker version for box creation
  box: amarburg/golang-ffmpeg:wheezy-1.8

  # This is the build pipeline.
  build:
    steps:
        - setup-go-workspace:
              package-dir: github.com/amarburg/go-lazycache

        - script:
            name: Build Go application
            code: |
              go get github.com/amarburg/go-lazycache
              go install github.com/amarburg/go-lazycache/cmd/lazycache-server/

        - internal/docker-push:
          username: _json_key
          password: $GCR_JSON_KEY_FILE
          repository: gcr.io/cloud-project-1234/go-lazycache-app
          registry: https://gcr.io
          entrypoint: /go/bin/golazycache-app
          ports: &quot;5000&quot;
          tag: $WERCKER_GIT_COMMIT, latest
          working-dir: $WERCKER_ROOT
</code></pre>

<p>Looks like a standard <code>wercker.yml</code>, and again uses the internal <a href="http://devcenter.wercker.com/docs/steps/internal-steps#docker-push">docker-push</a> step (I know I could have made this more sophisticated with additional pipelines and etc, but this is a good start).   This is cribbed from the wercker documentation on <a href="http://devcenter.wercker.com/docs/containers/pushing-containers">pushing containers</a>.</p>

<p>In this case, rather than pushing to Docker Hub, it pushes to a project-specific location at <code>grc.io</code>.   I am still figuring out access control to Google projects, but it looks like the basic level of project access is through service account keys:</p>

<p>{:center}
<img src="{{site.baseurl}}/images/credentials_dashboard.jpg" alt="" /></p>

<p>The service account key has an associated JSON file which is a <em>magic key</em> that gives you complete access to the project.  Mostly.  I think.   Well, at least programs which have the contents of the JSON file can get into the project, so it&rsquo;s, like, important for security.</p>

<p>The problem is how to get this critical security information to Wercker.  Sure can&rsquo;t check it into the Github repo (really!).   Wercker gets around this (and other similar problems), by allowing per-project (and per-step, and per-organization), environment variables.   These are set through the website (or the API?) and are associated with the project.  Of course, if it really mattered I think you&rsquo;d set up a &ldquo;only for pushing images&rdquo; key, and a &ldquo;allowed to access cloud storage key&rdquo;, etc.</p>

<p>{:center}
<img src="{{site.baseurl}}/images/wercker_environment_variables.jpg" alt="" /></p>

<p>For <code>docker-golang-ffmpeg</code>, the environment variables store my Docker username and password to allow pushing the image back to Docker.  For this project, it stores the contents of a JSON service account key.</p>

<p><em>Note, I learned most of this from a <a href="http://blog.wercker.com/deploying-a-microservice-to-gke-with-gcr">Wercker blog post</a>.  To repeat what Aaron says there:</em></p>

<blockquote>
<p><strong>IMPORTANT! You need to remove any newlines from the JSON file before pasting it in to the Wercker control panel:</strong></p>

<p>tr -d &ldquo;\n&rdquo; &lt; /path-to-downloaded-file.json</p>

<p><strong>If you miss the above step all push/pull attempts made to GCR will fail and it’ll make you re-evaluate every decision in your life that led up to the moment of the 100th failure. Trust me on that one.</strong></p>
</blockquote>

<p><em>Thanks!</em></p>

<p>The remaining options to <code>docker-push</code> are standard Dockerfile options:  entrypoint, ports, working-dir, etc., and image tags.  This is one of the wierd corners with wercker: it needs to wrap and replicate the Dockerfile format, because you aren&rsquo;t allowed to touch the Dockerfile itself for your project.  Then again, I can&rsquo;t suggest a better solution.</p>

<p>Again, of course all of this could be replicated on your very own desktop.</p>

<p>When all of the above runs correctly, a push to <code>lazycache-deploy</code> will fire off a Wercker job, which will build a <code>lazycache-deploy</code> Docker image:</p>

<p>{:center}
<img src="{{site.baseurl}}/images/wercker_lazycache_deploy.jpg" alt="" /></p>

<p>(or not, sometimes&hellip;)</p>

<p>which will end up in Google Container Registry:</p>

<p>{:center}
<img src="{{site.baseurl}}/images/container_registry.jpg" alt="" /></p>

<p>Here we can see two revision of the image sitting in the registry, tagged with the <code>lazycache-deploy</code> Git commit and <code>latest</code>.</p>

<h1 id="creating-an-instance">Creating an instance</h1>

<p><em>n.b. So somewhere in here you authenticate your command line client and set your default project.  I&rsquo;ve forgotten how that works, so I assume it&rsquo;s obvious&hellip;</em></p>

<p>Now that we have a Docker image, we can spin up an instance to host the image.   From the command line, that looks something like:</p>

<pre><code>gcloud compute instances create go-lazycache  \
      --image-family gci-stable  \
      --image-project google-containers  \
      --address go-lazycache  \
      --metadata-from-file user-data=cloud-init  \
      --tags http-server  \
      --zone us-west1-a  \
      --machine-type f1-micro
</code></pre>

<p>This uses the <code>gcloud</code> command line to create a new compute instance called <code>go-lazycache</code> in the zone <code>us-west1-a</code>, of type <code>f1-micro</code> (the machine types are described on the <a href="https://cloud.google.com/compute/pricing#machinetype">billing page</a>).</p>

<p>The address <code>go-lazycache</code> is an externally-visible IP address which has been pre-allocated using:</p>

<pre><code>gcloud compute addresses create &quot;go-lazycache&quot; --region &quot;us-west1&quot;
</code></pre>

<p>I believe the tag <code>http-server</code> automagically configures the firewall to allow traffic through on port 80.</p>

<p>The new instance is pre-loaded with the latest stable image from the <a href="https://cloud.google.com/container-optimized-os/docs/">Container-Optimized OS</a> project from Google.   This is the <em>actual OS which runs on the instance</em>, and is based on Chromium OS.   It&rsquo;s designed to be mostly what you want (Docker and other stuff) and very little of what you don&rsquo;t (whatever that is).</p>

<p>The part that was hard for me to understand was that up to this point, this instance is utterly generic.   It&rsquo;s like a new, out-of-the-box computer with a fresh install of Linux (or Container-Optimized OS, as the case may be).   It doesn&rsquo;t know a thing about lazycache or who it&rsquo;s supposed to be.</p>

<p>The magic comes from the <code>metadata-from-file</code> line.   This adds a <a href="https://cloud.google.com/appengine/docs/java/datastore/metadataqueries">metadata tag</a> <code>user-data</code> to this instance which contains the contents of the file <code>cloud-init</code> (which is also in the <a href="https://github.com/amarburg/go-lazycache-app/blob/master/deploy/gce_standalone/cloud-init">lazycache-deploy</a> repo).   <code>cloud-init</code>, in turn is a <a href="https://cloudinit.readthedocs.io/en/latest/index.html">mostly standardized(?)</a> system for putting all of your cloud instance configuration in one massive file.   Which, believe it or not, is good for repeatability.</p>

<p>The cloud-init itself is pretty readable YAML (tho it bothers me to cut and paste whole files in the middle of a YAML file, but never mind that&hellip;.)</p>

<pre><code>#cloud-config

users:
- name: lazycache
  uid: 2000
  groups: docker

write_files:
- path: /etc/systemd/system/lazycache.service
  permissions: 0644
  owner: root
  content: |
    [Unit]
    Description=Start the lazycache service in a docker container

    [Service]
    User=lazycache
    Environment=&quot;HOME=/home/lazycache&quot;
    ExecStartPre=/usr/share/google/dockercfg_update.sh
    ExecStart=/usr/bin/docker run --rm -u 2000 --publish 80:5000 --name=go-lazycache gcr.io/cloud-project-1234/lazycache-deploy:latest
    ExecStop=/usr/bin/docker stop go-lazycache
    ExecStopPost=/usr/bin/docker rm go-lazycache

runcmd:
- systemctl daemon-reload
- systemctl start lazycache.service
</code></pre>

<p>This creates a new user <code>lazycache</code> and ensures it is a member of the Docker group, then defines a new <a href="https://www.freedesktop.org/wiki/Software/systemd/">systemd</a> script.   This runs as that newly created user, and basically does a totally standard <code>docker run</code> on the <code>latest</code> version of the Docker image we previously stored in Cloud Registry.</p>

<blockquote>
<p><em>Just looking at it, I&rsquo;m sure there are other ways to do it.   For example, the lazycache.service could run on startup by making it dependent on some system service, rather than explicitly <code>systemctl start</code>ing it.  Anyway, this works for now.</em></p>
</blockquote>

<p>I found I needed one little bit of black magic here.  By default, I thought that instances in a project were given relatively broad permissions within the project, but initially the instance didn&rsquo;t have permission to pull the Docker image from GCR.  Explicitly calling <code>dockercfg_update.sh</code> made it work, so it clearly does some authentication, though notably I didn&rsquo;t need to provide any secrets to it.   Come to think of it, I wonder if calling <code>gcloud docker</code> rather than <code>docker</code> would just work&hellip;.</p>

<p>Aaaanyway, with this cloud-init, the instance will start up, create a <code>lazycache-deploy</code> Docker image, and run it.</p>

<p>{:center}
<img src="{{site.baseurl}}/images/gcloud_sample_page.jpg" alt="" /></p>

<p>Neat!</p>

<p>The next step is to increase the configurability of the <code>lazycache</code> software itself and figure out how to get that into the image.   For example, right now the Google Cloud Storage bucket is hardcoded, which obviously will break for anyone who tries to use that functionality.</p>

<h1 id="party-tricks">Party tricks</h1>

<p>Just as a note, now that the instance is up and running, you can SSH to it:</p>

<pre><code>% gcloud compute ssh go-lazycache

aaron@go-lazycache ~ $ docker ps

CONTAINER ID        IMAGE                                                  COMMAND                  CREATED             STATUS              PORTS                  NAMES
c28a3d197782        gcr.io/cloud-project-1234/lazycache-deploy:latest   &quot;/go/bin/lazycache-se&quot;   5 days ago          Up 28 hours         0.0.0.0:80-&gt;5000/tcp   go-lazycache
</code></pre>

<p>And do Docker-y things.</p>

      </section>
      


    </article>
    <div class="ph3 mt2 mt6-ns">
      

    </div>
  </div>

    </main>
    <footer class="bg-near-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://camhd-analysis.github.io/" >
    &copy; 2019 CamHD Video Analysis
  </a>
  








  </div>
</footer>

    <script src="https://camhd-analysis.github.io/dist/app.bundle.js" async></script>

  </body>
</html>
