<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>CamHD Video Analysis  | Benchmarking Frame Access Methods (again)</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.31.1" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    <link href='https://camhd-analysis.github.io/dist/main.css' rel='stylesheet' type="text/css" />
    
      
    

    

    <meta property="og:title" content="Benchmarking Frame Access Methods (again)" />
<meta property="og:description" content="I&rsquo;ve made an effort to cleanup and regularize my benchmarking code, and have tested it on my desktop here (in Seattle), on the CamHD Compute Engine and on Google Cloud instances.
As detailed previously, we&rsquo;re exploring a few different methods for efficiently extracting individual frames from CamHD movies. Tim&rsquo;s pycamhd module does this extraction in native Python (with help from FFMpeg). My lazycache tool is designed to run as a service with an HTTP API, although coincidentally I&rsquo;ve also developed a Python wrapper around the core Go-based frame extraction code." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://camhd-analysis.github.io/post/2017-05-15-benchmarking-pycamhd-part-two/" />



<meta property="article:published_time" content="2017-05-15T00:00:00&#43;00:00"/>

<meta property="article:modified_time" content="2017-05-15T00:00:00&#43;00:00"/>











<meta itemprop="name" content="Benchmarking Frame Access Methods (again)">
<meta itemprop="description" content="I&rsquo;ve made an effort to cleanup and regularize my benchmarking code, and have tested it on my desktop here (in Seattle), on the CamHD Compute Engine and on Google Cloud instances.
As detailed previously, we&rsquo;re exploring a few different methods for efficiently extracting individual frames from CamHD movies. Tim&rsquo;s pycamhd module does this extraction in native Python (with help from FFMpeg). My lazycache tool is designed to run as a service with an HTTP API, although coincidentally I&rsquo;ve also developed a Python wrapper around the core Go-based frame extraction code.">


<meta itemprop="datePublished" content="2017-05-15T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2017-05-15T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="731">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Benchmarking Frame Access Methods (again)"/>
<meta name="twitter:description" content="I&rsquo;ve made an effort to cleanup and regularize my benchmarking code, and have tested it on my desktop here (in Seattle), on the CamHD Compute Engine and on Google Cloud instances.
As detailed previously, we&rsquo;re exploring a few different methods for efficiently extracting individual frames from CamHD movies. Tim&rsquo;s pycamhd module does this extraction in native Python (with help from FFMpeg). My lazycache tool is designed to run as a service with an HTTP API, although coincidentally I&rsquo;ve also developed a Python wrapper around the core Go-based frame extraction code."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://camhd-analysis.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      CamHD Video Analysis
    </a>
    <div class="flex-l items-center">
      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/howto/" title=" page">
              
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/page/" title="Pages page">
              Pages
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/post/" title="Posts page">
              Posts
            </a>
          </li>
          
        </ul>
      
      








    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  <div class="flex-l mt2 mw8 center">
    <article class="center cf pv5 ph3 ph4-ns mw7">
      <p class="f6 b helvetica tracked">
        
        POST
      </p>
      <h1 class="f1 athelas">
        Benchmarking Frame Access Methods (again)
      </h1>
        
        
      <time class="f6 mv4 dib tracked" datetime="2017-05-15T00:00:00Z">
        May 15, 2017
      </time>
      <section class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray">
        

<p>I&rsquo;ve made an effort to cleanup and regularize <a href="https://github.com/CamHD-Analysis/jupyter-lazyqt-benchmarking.git">my benchmarking code</a>, and have tested it on my desktop here (in Seattle), on the <a href="https://chiron.ldeo.columbia.edu">CamHD Compute Engine</a> and on Google Cloud instances.</p>

<p>As <a href="{{ site.baseurl }}{% post_url 2017-05-01-benchmarking-pycamhd %}">detailed previously</a>, we&rsquo;re exploring a few different methods for efficiently extracting individual frames from CamHD movies.  Tim&rsquo;s <code>pycamhd</code> module does this extraction in native Python (with help from FFMpeg).   My <code>lazycache</code> tool is designed to run as a service with an HTTP API, although coincidentally I&rsquo;ve also developed a Python wrapper around the core Go-based frame extraction code.</p>

<h1 id="benchmarking">Benchmarking</h1>

<p>For this round of benchmarking, I&rsquo;m looking at scalability when parallelized as threads by <a href="http://dask.pydata.org/en/latest/">Dask</a>.</p>

<p>Each method is asked to perform the same task:   extract 100 random frames drawn
from a set of eight movies.  The total time of task execution is
repeated for 1, 2, 4, and 8 Dask threads.</p>

<p>All results run on the CamHD Compute Hub, a Core i7-920 with 4 cores.   First I compare Tim&rsquo;s pure-Python PycamHD to my Python-around-C-around-Go PyLazyQt.</p>

<table class="smaller_table">
  <tr>
    <th>Method</th>
    <th>Data source</th>
    <th>Cached?</th>
    <th>1 Threads<br/>Total time (s)</th>
    <th>2 Threads<br/>Total time (s)</th>
    <th>4 Threads<br/>Total time (s)</th>
    <th>8 Threads<br/>Total time (s)</th>
  </tr>
  <tr>
    <td> <a href="https://github.com/tjcrone/pycamhd">PyCamHD</a> </td>
    <td>Direct disk access</td>
    <td>No</td>
    <td>5.08</td>
    <td>2.69</td>
    <td>1.89</td>
    <td>1.53</td>
  </tr>
  <tr>
    <td>PyLazyQt</td>
    <td>Direct disk access</td>
    <td>No</td>
    <td>5.50</td>
    <td>5.50</td>
    <td>5.62</td>
    <td>5.60</td>
  </tr>
  <tr>
    <td>PyLazyQt</td>
    <td>Local HTTP server</td>
    <td>No</td>
    <td>6.20</td>
    <td>6.28</td>
    <td>6.31</td>
    <td>6.42</td>
  </tr>
  <tr>
    <td>PyLazyQt</td>
    <td>Rutgers CI</td>
    <td>No</td>
    <td>41.05</td>
    <td>40.27</td>
    <td>40.64</td>
    <td>39.92</td>
  </tr>
</table>

<p>A couple of take-aways.   First, PyCamHD and PyLazyQT are roughly equivalent operating on local data &mdash; this implies the ProRes decoding (done by FFMpeg) is the primary bottleneck.    Second, PyCamHD scales with threads, by PyLazyQT doesn&rsquo;t.     Normally I would be bummed about this, but it&rsquo;s becoming apparent to me that PyLazyQT is kindof a mutt.   It provides a C API for this functionality which makes it easier to write extensions in other languages, but given we have a pure-Python API in PyCamHD, it doesn&rsquo;t really serve any purpose in the Python ecosystem.</p>

<p>Next, I tested access through a Lazycache instance running locally on
the CamHD Compute Hub server.  As before, the Lazycache server was configured to
access movies on the local disk, from local disk through a web server, <em>and</em> from CI.</p>

<p><table class="smaller_table">
    <tr>
      <th>Method</th>
      <th>Data source</th>
      <th>Cached?</th>
      <th>1 Threads<br/>Total time (s)</th>
      <th>2 Threads<br/>Total time (s)</th>
      <th>4 Threads<br/>Total time (s)</th>
      <th>8 Threads<br/>Total time (s)</th>
    </tr>
  <tr>
    <td>PyLazyCache</td>
    <td>Local Lazycache Server -&gt; Direct disk access</td>
    <td>No</td>
    <td>11.58</td>
    <td>6.53</td>
    <td>4.36</td>
    <td>4.60</td>
  </tr>
  <tr>
    <td>PyLazyCache</td>
    <td>Local Lazycache Server -&gt; Local HTTP Server</td>
    <td>No</td>
    <td>11.85</td>
    <td>6.79</td>
    <td>4.79</td>
    <td>4.61</td>
  </tr>
  <tr>
    <td>PyLazyCache</td>
    <td>Local Lazycache Server -&gt; Rutgers CI</td>
    <td>No</td>
    <td>25.31</td>
    <td>12.98</td>
    <td>7.24</td>
    <td>5.03</td>
  </tr>
  <tr>
    <td>PyLazyCache</td>
    <td>Local Lazycache Server -&gt; Direct disk access</td>
    <td><b>Yes</b></td>
    <td>5.91</td>
    <td>5.14</td>
    <td>5.30</td>
    <td>5.47</td>
  </tr>
  <tr>
    <td>PyLazyCache</td>
    <td>Local Lazycache Server -&gt; Local HTTP Server</td>
    <td><b>Yes</b></td>
    <td>6.40</td>
    <td>5.27</td>
    <td>5.51</td>
    <td>5.44</td>
  </tr>
  <tr>
    <td>PyLazyCache</td>
    <td>Local Lazycache Server -&gt; Rutgers CI</td>
    <td><b>Yes</b></td>
    <td>5.97</td>
    <td>5.20</td>
    <td>5.43</td>
    <td>5.36</td>
  </tr></p>

<p></table></p>

<p>Two interesting patterns emerge.  First, Lazycache is  thread-friendly, providing performance comparable with the baseline (unthreaded PyCamHD) when running in parallel.   It can&rsquo;t touch direct conversion in PyCamHD, which doesn&rsquo;t come as a surprise.    Previous benchmarking has shown that the bottleneck in Lazycache is the PNG encoding, the HTTPS encoding, and serialization onto the network (none of which PyCamHD has to deal with).</p>

<p>The cached results hint that this ~5-6 second baseline represents a hard limit of the system, as a successful cache hit requires no video processing, only two HTTP transmissions (an HTTP redirect to the cached file, then serving the cached file).</p>

<p>We can extend this testing to use a public hosted instance of Lazycache, pulling from CI:</p>

<p><table class="smaller_table">
    <tr>
      <th>Method</th>
      <th>Data source</th>
      <th>Cached?</th>
      <th>1 Threads<br/>Total time (s)</th>
      <th>2 Threads<br/>Total time (s)</th>
      <th>4 Threads<br/>Total time (s)</th>
      <th>8 Threads<br/>Total time (s)</th>
    </tr>
  <tr>
    <td>PyLazyCache</td>
    <td>Google App Engine Lazycache Server -&gt; Rutgers CI</td>
    <td>No</td>
    <td>198.57</td>
    <td>122.12</td>
    <td>105.96</td>
    <td>101.39</td>
  </tr>
  <tr>
    <td>PyLazyCache</td>
    <td>Google App Engine Lazycache Server -&gt; Rutgers CI</td>
    <td><b>Yes</b></td>
    <td>89.23</td>
    <td>50.70</td>
    <td>30.53</td>
    <td>25.05</td>
  </tr>
</table></p>

<p>There is a <em>huge</em> decrease in performance given the network latency between the Compute Hub (in New York) and the GAE instance in Iowa.</p>

<p>Finally, test querying the Google app engine Lazycache from a Google compute engine instance situated in the same datacenter zone, <code>us-central-1</code>.   In theory this node should have maximal real-world bandwidth to the Lazycache app server.</p>

<table class="smaller_table">
  <tr>
    <th>Method</th>
    <th>Data source</th>
    <th>Cached?</th>
    <th>1 Threads<br/>Total time (s)</th>
    <th>2 Threads<br/>Total time (s)</th>
    <th>4 Threads<br/>Total time (s)</th>
    <th>8 Threads<br/>Total time (s)</th>
  </tr>

  <tr>
    <td>PyLazyCache on Google Compute Engine </td>
    <td>Google App Engine Lazycache Server -> Rutgers CI</td>
    <td>No</td>
    <td>216.46</td>
    <td>98.33</td>
    <td>60.50</td>
    <td>41.83</td>
  </tr>
  <tr>
    <td>PyLazyCache on Google Compute Engine </td>
    <td>Google App Engine Lazycache Server -> Rutgers CI</td>
    <td><b>Yes</b></td>
    <td>152.77</td>
    <td>80.20</td>
    <td>41.93</td>
    <td>20.25</td>
  </tr>
</table>

      </section>
      


    </article>
    
  </div>

    </main>
    <footer class="bg-near-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://camhd-analysis.github.io/" >
    &copy; 2018 CamHD Video Analysis
  </a>
  








  </div>
</footer>

    <script src="https://camhd-analysis.github.io/dist/app.bundle.js" async></script>

  </body>
</html>
